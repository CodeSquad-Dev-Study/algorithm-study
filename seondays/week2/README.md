## 2주차 : 그래프 [🔗](https://www.acmicpc.net/workbook/view/9562)
### 문제 목록
#### 11724번 연결 요소의 개수
- 주어진 간선의 시작 점들을 key로 하여 `map` 자료구조에 저장하고, 이를 `graph` 변수에 할당한다.
- 예를 들면 2,3 2,1 2,5 이렇게 쌍이 주어진 경우 2 : [3,1,5] 이렇게 저장하고, 3 : [2], 1 : [2], 5 : [2]로도 저장한다.
- 여기서 주의할 점은 정점은 존재하지만 해당 정점이 속한 간선이 없는 경우가 있다.
이를 `graph`에 추가하지 않을 경우 `NullPointer` 예외가 발생하므로, 주어진 정점들을 모두 key로 만들어서 추가해주는 초기화 작업을 진행하는 것이 좋다.
- 이렇게 양방향 연결 그래프 정보를 담은 자료구조를 가지고 `dfs`를 실행한다.
- 그런데 고려해야 할 점은, 지금 우리가 탐색하는 그래프는 전체가 다 연결된 그래프가 아닐수도 있다는 점이다.
만약 하나의 정점에서 `dfs`를 실행하기만 할 경우, 해당 정점과 연결되어 있지 않은 연결 요소는 탐색할 수가 없게 된다.
- 따라서 모든 정점을 순회하면서 `visit`를 체크하고 `dfs`를 돌려야 한다. 이를 위해 정점의 개수만큼 반복문을 돌되, 다시 해당 반복문의 내부에서 `dfs`를 실행하도록 한다.

#### 5567번 결혼식
- dfs로 탐색하되, 깊이 제한을 둬서 일정 깊이 이상으로는 들어가지 않도록 제한하는 방법 사용.

#### 11403번 경로 찾기
- 플루이드-와샬 알고리즘 사용 &rarr; 모든 노드를 중간에 거쳐가는 경우의 수를 탐색해야만 한다.
- 원래 알고리즘은 이렇게 모든 노드를 탐색하면서 거쳐갈 수 있는 가장 작은 비용으로 갱신하는 것이지만 경로 찾기 문제에서는 그냥 거쳐서 갈 수 있기만 하면 된다.
- 경유지-시작-끝 의 모든 요소를 다 돌아야 하기 때문에 시간 복잡도는 O^3
- 경로 찾기 문제같은 경우 2번 노드를 거쳐간다고 생각해보았을 때, 예를 들면 1 &rarr; 2 & 2 &rarr; 3 이 되려면 행렬의 해당 좌표값이 둘 다 1이면 거쳐서 가는 길이 존재하는 것이다.

#### 2660번 회장뽑기
- 역시 플루이드-와샬 알고리즘
- 1촌,2촌,3촌을 계산하기 위해서는 중간 노드를 거치는 모든 경우의 수를 계산하면서 min 값으로 세팅한다.
  - 1촌이 가장 min인 경우인데 다른 중간 노드를 거칠 경우 3촌이 나올 수도 있기 때문에 min 값을 구해야 함
- 그리고 만들어진 행렬을 돌면서 가장 작은 점수를 찾고, 그에 해당되는 사람의 번호를 찾는다.

#### 1389번 케빈 베이컨의 6단계 법칙
- 1촌 구하는 개념으로 플루이드-와샬 알고리즘을 적용 가능하지만, bfs로 풀이해보았다.
- 넓이 우선 탐색을 하면 자연스럽게 1촌을 모두 탐색한 후 1촌의 1촌 즉 2촌을 탐색하게 되므로 한 단계 들어갈 때 마다 기존값에서 +1을 해준다.

#### 1325번 효율적인 해킹
- dfs로 풀이하는데 계속 시간초과;;
- 바꿔본 것들
  - visit 체크 Set으로 하는 경우 &rarr; 배열로 하기
  - graph Map으로 하는 경우 &rarr; 2중 Array로 하기
  - 재귀에서 값을 return해서 가장 처음 함수에서 다 더해주는 방식으로 하는 경우 &rarr; 값을 저장할 배열을 따로 선언해준 후 더해줌