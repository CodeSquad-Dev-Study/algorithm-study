## 4주차 : 원하는 문제 [⚾️](https://www.acmicpc.net/workbook/view/2052)
#### 13265번 색칠하기 [🔗](https://www.acmicpc.net/problem/13265)
- 이전 dot의 색상과 지금 dot의 색이 달라야 한다.
- 2가지 색은 1과 0으로 설정해서 dfs마다 색이 달라지도록 설정
#### 14500번 테트로미노 [🔗](https://www.acmicpc.net/problem/14500)
- 모든 경우마다 모양에 따른 합산결과가 다를 것이므로 visit을 체크한다던가 하는 로직이 필요 없다.
- 따라서 그냥 단순하게 다 대입해서 체크하면 될 듯. 시간복잡도도 500 * 500 * 테트로미노 경우의 수 하면 시간 안에 가능하다.
- 다만 bfs로도 풀이 가능함
#### 15649번 N과 M(1) [🔗](https://www.acmicpc.net/problem/15649)
- 완전탐색 후 조건에 따라 수를 출력하는 문제 백트래킹
- 트리 형식으로 한 자리씩 다음 수를 조건에 맞게 선택하고, 조건에 맞지 않을 경우 다시 back
- 중복 없이 선택하라는 조건이 있기 때문에 visit을 체크하면서 계산해야 한다
- 숫자 선택을 쌓아가는 `sequence`는 한 단계 되돌아올 때 마다 마지막으로 추가된 숫자를 지워야 한다.
#### 15650번 N과 M(2) [🔗](https://www.acmicpc.net/problem/15650)
- 출력되는 수열이 오름차순이어야 한다는 조건
- 오름차순이라는 것은 현재 자리수의 숫자보다 다음 자리 숫자가 커야 한다.
- 즉 내부 트리를 반복하는 부분에서 시작점을 현재 숫자보다 +1 해서 함수 재귀호출 필요
#### 15651번 N과 M(3) [🔗](https://www.acmicpc.net/problem/15651)
- 중복 허용 &rarr; 즉 모든 조합 출력
- 기존 하던대로 ArrayList에 조합을 저장하고 출력했더니 시간초과
- ArrayList 대신 Array, 그리고 StringBuilder로 출력하도록 변경 후 통과
#### 15652번 N과 M(4) [🔗](https://www.acmicpc.net/problem/15652)
- 고른 수열은 비내림차순이어야 한다. &rarr; 현재 자리수의 숫자보다 다음 자리 숫자가 같거나 커야 한다.
- 즉 앞서 저장한 숫자를 확인해서 해당 숫자보다 크거나 같을 경우에만 이어서 선택한다