## 3주차 : BFS [🔗](https://www.acmicpc.net/workbook/view/7313)
### 문제 목록
#### 1926번 그림
- 그래프를 순회하면서 위치 값이 1일 경우 bfs 호출.
- 시작지점으로부터 연결된 네방향의 값이 1인 경우를 찾고, 해당 값을 큐에 집어넣는다.
- 큐에 값이 없을 때 까지(== 즉 1인 값이 더 이상 없는 경우) 반복해서 네방향의 값을 찾는다.
- 전체 그래프에서 1 값이 없어질 때 까지 반복한다.
- 방문 처리를 queue에 추가하는 순간에 같이 해주는 것이 핵심. 반복문이 시작할 때 처리를 하는 경우 중복된 값이 큐에 저장되어 잘못된 결과가 나온다.
#### 7576번 토마토
- 익은 토마토가 1개 이상일 수 있기 때문에, 하루가 지났다고 했을 때 이 토마토들은 자신 주변의 토마토를 익게 한다.
- 따라서 하나의 출발점에서 bfs가 출발해서는 안 되고, 병렬적으로 모든 토마토가 동시에 익어가기 시작해야 한다. &rarr; 이를 한꺼번에 미리 큐에 담아놓는다.
- 날짜 계산은 그래프에서 이전 노드의 일수에 +1을 하여 익어가는 날짜를 계산한다.
#### 4179번 불
- 처음에는 하나의 그래프에서 불이 퍼지는 정보와 지훈이가 이동하는 정보를 한꺼번에 기록하고, 불 퍼지고-지훈이 이동을 한 라운드로
관리하려고 했다.
- 이렇게 하니까 고려해야 할 부분이 너무 많아지고 코드가 복잡해져서 다른 방법을 찾아보게 되었음
- 불과 지훈이를 번갈아가면서 도는게 아니라, 각각 bfs를 반복하는 방법 사용
- 불이 번지는 시간을 먼저 전체 다 구해서 저장해두고, 그 다음 지훈이를 이동시켜서 불 그래프와 비교한다.
- 한 가지 주의할 것은 지훈이가 1분만에 미로를 빠져나갈 수 있는 방법이 있는지를 따로 체크해줘야 한다는 것.
#### 1697번 숨바꼭질
- 가장 빠른 경우의 수를 찾는다고 했음 &rarr; BFS 사용
- `visit` 배열을 처음에는 0부터 end값까지로 만드려고 했는데, end값보다 더 큰 숫자를 사용하는 경우도 있을 수 있음
  - 배열의 크기를 10001로 설정해서 사용
- index 범위 오류가 나지 않도록 주의 필요
#### 1012번 유기농 배추
- 전체 그래프를 돌면서 모든 1을 만날 때 마다 bfs를 돌려주고, bfs마다 result를 1 증가시킨다.
#### 10026번 적록색약
- 유기농 배추와 거의 유사하지만, R과 G를 한 가지 그룹으로 생각해야 하므로 처음 그래프를 입력받을 때 R이면 G로 바꿔서 저장하도록 한다.
- 그 이후 동일하게 bfs를 돌려서 결과 계산